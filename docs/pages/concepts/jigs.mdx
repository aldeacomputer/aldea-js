---
title: 'Jigs'
---

import {CodeContainer} from '../../customComponents/codeContainer'

# Jigs

A Jig is a programmable digital object that can contain state and behaviour. A Jig has methods that allows it to be interacted with from the outside world or by other Jigs.

On Aldea, *everything is a Jig!* The Aldea Computer can be thought of as a machine made up of many Jigs interacting with each other. From tokens and NFTs to smart contracts and DeFi, all use cases are implemented as Jigs.

If you are familiar with object oriented programming, you're familiar with Jigs:

<CodeContainer lang="ts">
    ```
    export class Counter extends Jig {
      count: i64 = 0

      increase(): void {
        this.count++
      }

      decrease(): void {
        this.count--
      }

      reset(): void {
        this.count = 0
      }
    }
    ```
</CodeContainer>

## Understanding Jigs

- Jig classes are written in AssemblyScript, a language that is similar to TypeScript and will be familiar to many developers.
- A Jig is **an instance** of a class that inherits from the `Jig` parent class.
- Jigs have typed properties that can store state, and methods that allow the Jig to be interacted with.

## Jig authorization

Jigs can be read by anyone, but only those with permission can update them. Jigs have a lock, and the type of lock determines who is allowed to update the Jig. There are three primary lock types offered by Aldea:

- **Lock to Address**: The most common lock type for Jigs is to be locked to an address (a hash of a public key). A transaction must be signed by the address' corresponding private key in order to interact with the Jig. When a valid signature exists, methods can be called on the Jig and its lock type can be changed.
- **Lock to Caller**: A Jig can be locked to another Jig, so that it can only be interacted with or have its lock changed when the caller is the Jig it is locked to.
- **Lock to Anyone**: When a Jig is locked to anyone, it has a shared lock that allows anyone to call its methods, but no one can change the Jig's lock type. This enables powerful smart contract use cases.

A Jig is created in an **unlocked** state, which means that anyone can call its methods and set its lock type. Previously locked Jigs can also be unlocked. However a transaction cannot result in unlocked Jigs. This means that if a Jig is unlocked, it must be locked in a subsequent instruction in the same transaction.

Jigs can also be **frozen**, which means that they cannot be updated by anyone. They remain frozen indefinitely.

## Referenceing Jigs

Jigs are created and updated through transactions. When a transaction is executed, all the necessary information about the current state of the Jigs it affects are captured in its outputs. A Jig can be updated many times, creating a chain of outputs.

There are two ways to reference a specific Jig: by its `output_id`, which is a unique 32-byte hash of the output, or by its `origin`, which is a 36-byte Pointer. A Pointer is made up of the transaction ID and output index concatenated into one value. Outputs contain both a `location` (the current Pointer) and `origin` (the Jig's first ever Pointer).

To reference a specific Jig, use its `output_id`. If you don't know the most recent `output_id` of a Jig, you can use its `origin` to refer to it.

## Further reading

- [Transactions](/concepts/transactions)
- [Glossary](/concepts/glossary)
