---
title: 'Jigs'
---

import {CodeContainer} from '../../customComponents/codeContainer'

# Jigs

A Jig is a programmable digital object. Like any object, Jigs contain state and behaviour, and can be interracted with through methods. But Jig's exist on a blockchain and have some special charcteristics because of this.

A Jig's behavior is "deterministic", meaning that it will always produce the same result given the same starting state and conditions. The source code that describes this behavior is publicly available, and the history of a Jig can be traced and reviewed by anyone. Jigs can be controlled by different entities - individuals, organisations, even other Jigs!

On Aldea, *everything is a Jig!* The Aldea Computer can be thought of as a machine made up of many Jigs interacting with each other. From tokens and NFTs to smart contracts and DeFi, all use cases are implemented as Jigs.

<CodeContainer lang="ts">
    ```
    export class Counter extends Jig {
      count: i64 = 0

      increase(): void {
        this.count++
      }

      decrease(): void {
        this.count--
      }

      reset(): void {
        this.count = 0
      }
    }
    ```
</CodeContainer>

## Jig authorization

Jigs can be read by anyone, but only those with permission can update them. Jigs have a lock, and the type of lock determines who is allowed to update the Jig. There are three primary lock types offered by Aldea:

- **Lock to Address**: The most common lock type for Jigs is to be locked to an address (a hash of a public key). A transaction must be signed by the address' corresponding private key in order to interact with the Jig. When a valid signature exists, methods can be called on the Jig and its lock type can be changed.
- **Lock to Caller**: A Jig can be locked to another Jig, so that it can only be interacted with or have its lock changed when the caller is the Jig it is locked to.
- **Lock to Anyone**: When a Jig is locked to anyone, it has a shared lock that allows anyone to call its methods, but no one can change the Jig's lock type. This enables powerful smart contract use cases.

A Jig is created in an **unlocked** state, which means that anyone can call its methods and set its lock type. Previously locked Jigs can also be unlocked. However a transaction cannot result in unlocked Jigs. This means that if a Jig is unlocked, it must be locked in a subsequent instruction in the same transaction.

Jigs can also be **frozen**, which means that they cannot be updated by anyone. They remain frozen indefinitely.

## Referenceing Jigs

Jigs are created and updated through transactions. When a transaction is executed, all the necessary information about the current state of the Jigs it affects are captured in its outputs. A Jig can be updated many times, creating a chain of outputs.

There are two ways to reference a specific Jig: by its `output_id`, which is a unique 32-byte hash of the output, or by its `origin`, which is a 36-byte Pointer. A Pointer is made up of the transaction ID and output index concatenated into one value. Outputs contain both a `location` (the current Pointer) and `origin` (the Jig's first ever Pointer).

To reference a specific Jig, use its `output_id`. If you don't know the most recent `output_id` of a Jig, you can use its `origin` to refer to it.

## Further reading

- [Transactions](/concepts/transactions)
- [Glossary](/concepts/glossary)
