---
title: 'Create your first transaction'
---

import {CodeContainer} from '../../customComponents/codeContainer'

# 3. Create your first transaction

In the last step you deployed your first package. Now comes the fun part -  **It's time to create and interact with some [Jigs](/concepts/jigs)!**

![illustration](/3-tx.png)

In this last part of the guide we'll create an instance of our class `Item` and then update it by calling the `addPower()` method. We'll need to build some transactions to do this, so let's jump in.

## Creating an instance

Create a file in the `/scripts` directory called `create-item.ts` and copy and paste the following code (replacing `<PACKAGE_ID>` with the package ID you copied in the previous step):

<CodeContainer lang="ts">
    ```
    import { env, log, logOutput, logErrAndQuit } from '@aldea/cli'

    await env.loadWallet()
    const addr = await env.wallet.getNextAddress()

    const tx = await env.wallet.createFundedTx(txb => {
      const pkg = txb.import('<PACKAGE_ID>')
      const item = txb.new(pkg, 'Item', ['Ray Gun'])
      txb.lock(item, addr)
    }).catch(logErrAndQuit)

    const res = await env.wallet.commitTx(tx).catch(logErrAndQuit)
    const out = await env.aldea.loadOutput(res.outputs[0].id)
    log('Created item:')
    logOutput(out)
    ```
</CodeContainer>

The juicy part of this script is lines 6 to 10 - this is where the transaction-building magic happens. An Aldea transaction is simply a list of instructions so lets the follow the code and see if we can work out what is happening...

- Line 7 declares an `IMPORT` instruction which states we want to import the packge we deployed in the previous step.
- Line 8 declares a `NEW` instructions which states we want to instantiate a new `Item` instance. The last argument is an array of values that will get passed directly the constructor method. If you look at the source code in `/aldea/item.ts` you'll see the constructor accepts a single `name` parameter. You can change `"Ray Gun"` to any value you like.
- Line 9 adds a `LOCK` instruction. New instances of Jigs by default are unlocked, so here we state that the Jig should be locked to the address we fetched from the CLI wallet on line 4.

If at this point you were to inspect the built transaction with `log(tx)`, you'd see that the transaction contains more than the 3 instructions specified above. This is because the `wallet.createFundedTx()` method automatically adds some instructions to load a coin from your wallet, split the coin, fund the transaction and send change back to your wallet.

Let's run the script:

<CodeContainer lang="bash" lines={false}>
    ```
    npm run script create-item
    ```
</CodeContainer>

The script will respond with an output similar to:

<CodeContainer lang="text" lines={false}>
    ```
    Created item:
    ID       ce790f779716232159d0e882b631563b70b07ec010d9c21e6a5e97ae45d66b24
    Origin   95609cecfcef323b1383aa4ae20c0f0b7c7bda84a5ac16192e951ea3c0c92021_0
    Location 95609cecfcef323b1383aa4ae20c0f0b7c7bda84a5ac16192e951ea3c0c92021_0
    Class    03dfd237e64e98c891fdcd177dc5fa28fe6bd817f915cea9d7ddb0a025aba5b1_0
    State    { name: 'Ray Gun', power: 1 }       
    ```
</CodeContainer>

What do all these values mean?

- `ID` - the unique ID of the output. Output IDs are a content-addressable hash of a serialized version of the output.
- `Location` - a Pointer - a composite value made up of the transaction ID and output index where the instance can be found.
- `Origin` - another Pointer made up of the transaction ID and output index where the Jig was first seen. As this is a new instance, the `Location` and `Origin` are the same.
- `Class` - another Pointer, this time made up of the package ID and the export index where the class definition can be found.
- `State` - the current state of the Jig.

## Updating an instance

Congratulations! You've created your first Jig. You now own a `Ray Gun` with a power of `1`... Time for more power!

In the `/scripts` directory create a new script called `powerup.ts`. Copy and paste the following code (replacing `<OUTPUT_ID>` with the output ID from the result of the previous script):

<CodeContainer lang="ts">
    ```
    import { env, log, logOutput, logErrAndQuit } from '@aldea/cli'

    await env.loadWallet()

    const tx = await env.wallet.createFundedTx(txb => {
      const item = txb.load('<OUTPUT_ID>')
      txb.call(item, 'addPower', [10])
    })

    const res = await env.wallet.commitTx(tx).catch(logErrAndQuit)
    const out = await env.aldea.loadOutput(res.outputs[0].id)
    log('Updated item:')
    logOutput(out)
    ```
</CodeContainer>

Lines 5 to 8 define a transaction with two instructions.

- Line 6 declares a `LOAD` instructions which states we want to load a Jig by the output ID. We don't need to import the package as loading the Jig implicitly loads the package.
- Line 7 adds a `CALL` instruction which calls a method on an instance. In this case we're calling the `addPower()` method and passing an argument of `10`.

As before the wallet will automatically fund the transaction. Let's give it a go...

<CodeContainer lang="bash" lines={false}>
    ```
    npm run script powerup
    ```
</CodeContainer>

The command will respond with an output like this:

<CodeContainer lang="text" lines={false}>
    ```
    Updated item:
    ID       88a2c7b84d3629d104a3599a87cca5063597a1a22a40c7dee1a43db1e59eb833
    Origin   95609cecfcef323b1383aa4ae20c0f0b7c7bda84a5ac16192e951ea3c0c92021_0
    Location 3d689fb0aac98da988b8b5a6fc721ebbd4392739a89aa752dbcfcfdb59baf4a0_0
    Class    03dfd237e64e98c891fdcd177dc5fa28fe6bd817f915cea9d7ddb0a025aba5b1_0
    State    { name: 'Ray Gun', power: 11 }       
    ```
</CodeContainer>

So, what do we notice?

- Your Jig instance has a new `ID` and `Location` - you've just created a new transaction so the Location reflects where the Jig instance can now be found.
- The `Origin` and `Class` values are unchanged - these values will stay the same throught the life of the Jig.
- The `State` has been updated to reflect the change to the `power` property after the `addPower()` method call.

## Making improvements

Try updating your `powerup.ts` script so that the `LOAD` instruction loads the latest output ID, and run the script again. It should boost your item's power again. And again and again if you keep doing it. It's actually quite trivial to max out your item's power. This feels like something we can improve.

Imagine if the `addPower()` method in `item.ts` recieved a `Powerup` Jig instead of an integer. This would mean you can only powerup your item if you control a `Powerup` Jig. In our imaginary game, powerups could be a rare resourse.

<CodeContainer lang="ts">
    ```
    addPower(powerup: Powerup): void {
      this.power = min(this.power + powerup.power, 100)
      powerup.$lock.freeze() // Powerup is frozen after one use
    }
    ```
</CodeContainer>

Try defining a `Powerup` class in `item.ts` and updating the `Item#addPower()` method. You'll need to deploy the code again and update your scripts to use the new package ID. Can you create a script to create a new `Powerup` instance? Can you update the `powerup.ts` script to load both your item and powerup Jigs, and pass the powerup as an argument to the `addPower` method call?

## What next?

The simplicity of the Jig programming model opens up a world of endless possibilities, from creating tokens and game items to developing smart contracts and metaverse virtual worlds. On the Aldea Computer, you have the power to build the future of the on-chain world alongside a community of like-minded individuals. **Start building today and see where the limitless potential of Jigs can take you!**