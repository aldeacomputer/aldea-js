---
title: 'Deploy your first package'
---

import {CodeContainer} from '../../customComponents/codeContainer'

# Deploy your first package

In the previous steps, you have created a project, generated a new key pair, and received a coin to use for a transaction. Now, let's move on to deploying some code.

## What is a package?

A package is a collection of files and exports, written in AssemblyScript, that can be deployed to the Aldea Computer.

<CodeContainer lang="ts">
    ```
    export class Counter extends Jig {
      count: i64 = 0

      increase(): void {
        this.count++
      }

      decrease(): void {
        this.count--
      }

      reset(): void {
        this.count = 0
      }
    }
    ```
</CodeContainer>

In the example above, the `Counter` class extends from the `Jig` class, which means that every instance of the `Counter` class becomes part of the Aldea Computer and can be interacted with through transactions.

This example found in `aldea/counter.ts` is very simple, but packages can also be more complex, with multiple files and exports.

## Deploy A package

Your starter kit includes a more complex example of a Jig in `aldea/fighter.ts` that you can deploy. Take a moment to familiarize yourself with the code.

The kit also includes a script for deploying packages. To use it, you will need the `output_id` of the coin you received from the faucet.

<CodeContainer lang="base" lines={false}>
    ```
    npm run deploy fighter.ts --coin <OUTPUT_ID>
    ```
</CodeContainer>

The script will create a transaction using your coin and will provide a JSON output similar to:

<CodeContainer lang="json" lines={false}>
    ```
    {
      "txid": "1767774b77aabbddbf307c3176466584ff3256de8561e1612ace44b5196a2e6d",
      "outputs": [
        {
          "id": "f48ba904eeb603806ac41930df8063b5ab3ab5af80d0a8fefdf3ec681ea54f79",
          "origin": "305601c5834cb3b43fe68f6e4c580fd1d60afc74d69addfdd9739462bfa82877_0",
          "location": "1767774b77aabbddbf307c3176466584ff3256de8561e1612ace44b5196a2e6d_0",
          "class": "0000000000000000000000000000000000000000000000000000000000000000_0",
          "lock": { "type": 1, "data": "cbff30f7a721e4105f80f2d58a6caad4d6ae8242" },
          "state": "192648"
        }
      ],
      "packages": [
        {
          "id": "018cb96f98167917c9339e4f90c5863aff6d756083e742256c80cf9c9b99d78b",
          "files": [ "fighter.ts" ],
          "entries": [ "fighter.ts "],
        }
      ]
    }
    ```
</CodeContainer>

This is the JSON representation of a transaction result. It contains the following properties:

- `txid` - The transaction ID
- `outputs` - An array of outputs (Jigs) created by the transaction. This transaction has one output, which is change from the coin used to fund it. You still control this coin, so make a note of the new `output_id` for use in future transactions.
- `packages` - An array of packages deployed as a result of the transaction's instructions. The `fighter.ts` package is now deployed and has a package ID. Make a note of the package ID for use in future transactions.

## Transaction builder

Before moving on to the next section, let's examine the code in `scripts/deploy.js` to understand how the transaction was created. Find the code that looks like this:

<CodeContainer lang="ts">
    ```
    const coin = await aldea.loadOutput(argv.coin)

    const tx = await aldea.createTx(tx => {
      const coinRef = tx.load(coin.ref)
      tx.deploy(pkg)
      tx.call(coinRef, "send", [coin.motos - 100, address])
      tx.fund(coinRef)
    })

    await adea.commitTx(tx)
    ```
</CodeContainer>

Here's what each line does:

1. Firstly we load the output of the coin that will be used to fund the transaction. The state of the coin is loaded to ensure it has enough motos to fund the transaction.
    
    <CodeContainer lang="ts" lines={false}>
        ```
        const coin = await aldea.loadOutput(argv.coin)
        ```
    </CodeContainer>
    
2. The `createTx` function takes a callback function that receives a `TxBuilder` instance. Within the callback, you can add instructions to build the transaction. The function returns the built transaction.
    
    <CodeContainer lang="ts" lines={false}>
        ```
        const tx = await aldea.createTx(tx => {
          // builder code
        })
        ```
    </CodeContainer>
    
3. Even though the coin output has already been loaded outside of the transaction, a `LoadInstruction` must be added to the transaction. The builder function returns a reference to the instruction, which can be stored in a variable for use later in the transaction.
    
    <CodeContainer lang="ts" lines={false}>
        ```
        const coinRef = tx.load(coin.ref)
        ```
    </CodeContainer>
    
4. The `DeployInstruction` deploys a package of code to the Aldea Computer.
    
    <CodeContainer lang="ts" lines={false}>
        ```
        tx.deploy(pkg)
        ```
    </CodeContainer>
    
5. The `FundInstruction` specifies a coin to use to fund the transaction. The entire coin is given to the transaction processor as a fee. It is common to use the "send" method on the coin to send change back to yourself first, especially if the coin has more motos than the cost of the transaction.
    
    <CodeContainer lang="ts" lines={false}>
        ```
        tx.call(coinRef, "send", [coin.motos - 100, address])
        tx.fund(coinRef)
        ```
    </CodeContainer>
    
6. Finally, the transaction is committed to the Aldea computer with `adea.commitTx(tx)`. This returns the response we looked at earlier.
    
    <CodeContainer lang="ts" lines={false}>
        ```
        await adea.commitTx(tx)
        ```
    </CodeContainer>
    

## Next steps

- [Create and equip a fighter](/getting-started/instances)
- [Enter into battle](/getting-started/interacting)
